{-# LANGUAGE DeriveGeneric   #-}
{-# LANGUAGE RecordWildCards #-}

module Trader.Data.Order
  ( Order(..)
  , OrderId
  , ClientOrderId
  , OrderMap
  , toMap
  , isNew
  , module Trader.Data.Order.ExecutionInstruction
  , module Trader.Data.Order.OrderType
  , module Trader.Data.Order.PegPriceType
  , module Trader.Data.Order.Side
  , module Trader.Data.Order.TimeInForce
  ) where

import Data.Aeson (FromJSON, ToJSON, parseJSON, withObject, (.:), (.:?))
import qualified Data.Map.Strict as Map
import Data.Time.Clock (UTCTime)

import Trader.Data.Account (AccountId)
import Trader.Data.Currency (Currency)
import Trader.Data.Instrument (InstrumentSymbol)
import Trader.Data.Order.ExecutionInstruction (ExecutionInstruction (..))
import Trader.Data.Order.OrderStatus (OrderStatus (..))
import Trader.Data.Order.OrderType (OrderType (..))
import Trader.Data.Order.PegPriceType (PegPriceType (..))
import Trader.Data.Order.Side (Side (..))
import Trader.Data.Order.TimeInForce (TimeInForce (..))

type OrderMap = Map OrderId Order

type OrderId = Text

-- | Custom order id.
type ClientOrderId = Text

-- | Order.
data Order = Order
  { -- | Unique order id (generated by the BitMEX itself).
    orderId :: !OrderId
    -- | Client Order ID.
  , clientOrderId :: !ClientOrderId
  , accountId :: !AccountId
    -- | Instrument symbol.
  , symbol :: !InstrumentSymbol
    -- | Order side.
  , side :: !Side
    -- | Order quantity in units of the instrument (i.e. contracts).
  , orderQty :: !Int
    -- | Limit price for `Limit`, `StopLimit` and `LimitIfTouched` orders.
  , price :: !(Maybe Double)
    -- | Quantity to display in the book.
    -- Equals to 0 if this is a fully hidden order.
  , displayQty :: !(Maybe Double)
    -- | Trigger price for `Stop`, `StopLimit`,
    -- `MarketIfTouched`, and `LimitIfTouched` orders
  , stopPx :: !(Maybe Double)
    -- | Trailing offset from the current price.
  , pegOffsetValue :: !(Maybe Double)
    -- | Peg price type.
  , pegPriceType :: !(Maybe PegPriceType)
  , currency :: !Currency
  , settlCurrency :: !Currency
    -- | Order type.
  , orderType :: !OrderType
    -- | Specifies how long the order remains in effect.
  , timeInForce :: !TimeInForce
    -- | Execution instruction.
  , executionInstruction :: !(Maybe ExecutionInstruction)
    -- | Execution destination as defined by institution when order is entered.
  , executionDestination :: !Text
    -- | Order status.
  , status :: !OrderStatus
  , triggered :: !Text
  , workingIndicator :: !Bool
    -- | Rejection reason.
  , rejectionReason :: !(Maybe Text)
    -- | Leaves quantity in units of the instrument (i.e. contracts).
    -- Useful for amending partially filled orders.
  , leavesQty :: !(Maybe Int)
  , simpleCumQty :: !Double
  , cumQty :: !Int
  , avgPx :: !Double
  , multiLegReportingType :: !Text
    -- | Custom order annotation.
  , annotation :: !(Maybe Text)
  , transactTime :: !(Maybe UTCTime)
  , timestamp :: !(Maybe UTCTime)
  } deriving (Eq, Show, Generic)

instance FromJSON Order where
  parseJSON = withObject "Order" $ \o -> do
    orderId <- o .: "orderID"
    clientOrderId <- o .: "clOrdID"
    accountId <- o .: "account"
    symbol <- o .: "symbol"
    side <- o .: "side"
    orderQty <- o .: "orderQty"
    price <- o .:? "price"
    displayQty <- o .:? "displayQty"
    stopPx <- o .:? "stopPx"
    pegOffsetValue <- o .:? "pegOffsetValue"
    pegPriceType <- optional (o .: "pegPriceType")
    currency <- o .: "currency"
    settlCurrency <- o .: "settlCurrency"
    orderType <- o .: "ordType"
    timeInForce <- o .: "timeInForce"
    executionInstruction <- optional (o .: "execInst")
    executionDestination <- o .: "exDestination"
    status <- o .: "ordStatus"
    triggered <- o .: "triggered"
    workingIndicator <- o .: "workingIndicator"
    rejectionReason <- o .:? "ordRejReason"
    leavesQty <- o .:? "leavesQty"
    simpleCumQty <- o .: "simpleCumQty"
    cumQty <- o .: "cumQty"
    avgPx <- o .: "avgPx"
    multiLegReportingType <- o .: "multiLegReportingType"
    annotation <- o .:? "text"
    transactTime <- o .:? "transactTime"
    timestamp <- o .:? "timestamp"
    return Order{..}

instance ToJSON Order

instance ToText Order where
  toText Order{..} = unlines
    [ show side <> " " <> maybe "" show price <> " " <> show orderType <> " (" <> show status <> ") "
    , "[" <> show orderId <> " / " <> show accountId <> "] " <> maybe "" show timestamp
    ]

isNew :: Order -> Bool
isNew Order{..} = status == New

toMap :: [Order] -> OrderMap
toMap = Map.fromList . fmap (\o@Order{..} -> (orderId, o))
